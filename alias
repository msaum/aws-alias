#!/usr/bin/env bash
[toplevel]

###############
### GENERAL ###
###############

## Shortcuts
ag = apigateway
as = autoscaling
cfn = cloudformation
cp = codepipeline
ddb = dynamodb
eb = elasticbeanstalk
ec = elasticache
sc = servicecatalog
sg = security-group

tostring =
  !f() {
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." ; return 1 ; }
    cat "${1}" | jq 'tostring'
  }; f

# List or set your region
# Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws region [region]
region =
  !f() {
    [ $# -eq 1 ] && aws configure set region "$1" || aws configure get region;
  }; f

# List or set your region
# Usage: aws profiles
profiles =
  !f() {
    echo "export AWS_DEFAULT_PROFILE= to set a default profile."
    echo "Currently: AWS_DEFAULT_PROFILE=$AWS_DEFAULT_PROFILE"
    aws configure list-profiles
  }; f

# Upgrade to the latest version of the AWS CLI v2
# Usage: aws upgrade
upgrade =
  !f() {
    CURL_CLI=$(which curl) || { echo "ERROR: curl not installed." ; return 1 ; }
    UNZIP_CLI=$(which unzip) || { echo "ERROR: unzip not installed." ; return 1 ; }
    CUT_CLI=$(which cut) || { echo "ERROR: cut not installed." ; return 1 ; }
    SUDO_CLI=$(which sudo) || { echo "ERROR: sudo not installed." ; return 1 ; }
    UNAME_CLI=$(which uname) || { echo "ERROR: uname not installed." ; return 1 ; }

    [ $($UNAME_CLI) = "Darwin" ] &&  {
	    echo "OS: OSX / Darwin"
	    echo "Current version: $(aws --version | $CUT_CLI -d' ' -f 1)"
	    echo "Downloading AWS CLI v2..."
      $CURL_CLI --fail -sS https://awscli.amazonaws.com/AWSCLIV2.pkg -o /tmp/AWSCLIV2.pkg
      if [ ! -f  "/tmp/AWSCLIV2.pkg" ]; then
        echo "ERROR: Unable to download: https://awscli.amazonaws.com/AWSCLIV2.pkg"
        return 1
      fi
      $SUDO_CLI installer -pkg /tmp/AWSCLIV2.pkg -target /
      rm -f /tmp/AWSCLIV2.pkg 2> /dev.null
	    echo "    New version $(aws --version | $CUT_CLI -d' ' -f 1)"
    }
    [ $($UNAME_CLI) = "Linux" ] && {
      echo "OS: Linux"
		  rm -f /tmp/awscliv2.zip 2> /dev/null
		  rm -rf /tmp/aws/ 2> /dev/null
	    echo "Downloading AWS CLI v2..."
	    $CURL_CLI --fail -sS "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
      if [ ! -f  "/tmp/awscliv2.zip" ]; then
        echo "ERROR: Unable to download: https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"
        return 1
      fi
	    $(cd /tmp && $UNZIP_CLI awscliv2.zip && rm -f /tmp/awscliv2.zip) 2> /dev/null
	    CURRENT_VER=$(aws --version | $CUT_CLI -d' ' -f 1)
	    NEW_VER=$(/tmp/aws/dist/aws --version | $CUT_CLI -d' ' -f 1)
	    echo "Current version: $CURRENT_VER"
	    echo "    New version: $NEW_VER"
	    if [ "${CURRENT_VER}" = "${NEW_VER}" ]; then
	      echo "Versions are the same, no changes."
	    else
  	    $SUDO_CLI /tmp/aws/install --update
      fi
		  rm -rf /tmp/aws/ 2> /dev/null
		}
  }; f

# Check for the latest version of the AWS CLI v2
# Usage: aws check-upgrade
# Removed, since it takes about the same amount to just upgrade the client.


# Update to the latest aliases file
# Usage: update-aliases
update-aliases =
    !f() {
      CURL_CLI=$(which curl) || { echo "ERROR: curl not installed." ; return 1 ; }
      CMP_CLI=$(which cmp) || { echo "ERROR: CMP not installed." ; return 1 ; }

      $CURL_CLI --fail -sS https://raw.githubusercontent.com/msaum/aws-alias/master/alias -o ${HOME}/.aws/cli/alias.$$
      if [ -f  "${HOME}/.aws/cli/alias.$$" ]; then
        echo "Downloaded https://raw.githubusercontent.com/msaum/aws-alias/master/alias"
      else
        echo "Unable to download https://raw.githubusercontent.com/msaum/aws-alias/master/alias"
        return 1
      fi
      if [ "$CMP_CLI ${HOME}/.aws/cli/alias ${HOME}/.aws/cli/alias.$$" ]; then
        echo "Files are different, updating ${HOME}/.aws/cli/alias"
        mv -f ${HOME}/.aws/cli/alias.$$ ${HOME}/.aws/cli/alias
      else
        echo "Files are are the same, not updating."
      fi
    }; f

# Install and check all prerequisites
# https://github.com/rhyeal/aws-rotate-iam-keys
install =
  !f() {
    UNAME_CLI=$(which uname) || { echo "ERROR: uname not installed." ; return 1 ; }

	  [ $($UNAME_CLI) = "Darwin" ] &&  {
      echo "OS: OSX / Darwin"
      BREW_CLI=$(which brew) || { echo "ERROR: brew not installed.  Please install brew: https://brew.sh/" ; return 1 ; }
      BREW_CLI=$(which jq) || { echo "WARNING: jq not installed, installing via brew..." ; $(brew install jq) ; }
    }
    [ $($UNAME_CLI) = "Linux" ] && {
      echo "OS: Linux"
      JQ_CLI=$(which jq) || { echo "ERROR: jq not installed.  Please install jq and re-run \"aws install\"." ; return 1 ; }
		}

    CHMOD_CLI=$(which chmod) || { echo "ERROR: chmod not found in path." ; return 1 ; }
    AWS_CLI=$(which aws) || { echo "ERROR: aws not installed." ; return 1 ; }
    FIND_CLI=$(which find) || { echo "ERROR: find not installed.  Please install find and re-run \"aws install\"." ; return 1 ; }
    SORT_CLI=$(which sort) || { echo "ERROR: sort not installed.  Please install sort and re-run \"aws install\"." ; return 1 ; }
    HEAD_CLI=$(which head) || { echo "ERROR: head not installed.  Please install head and re-run \"aws install\"." ; return 1 ; }
    SED_CLI=$(which sed) || { echo "ERROR: sed not installed.  Please install sed and re-run \"aws install\"." ; return 1 ; }
    GREP_CLI=$(which grep) || { echo "ERROR: grep not installed.  Please install grep and re-run \"aws install\"." ; return 1 ; }
    CUT_CLI=$(which cut) || { echo "ERROR: cut not installed.  Please install cut and re-run \"aws install\"." ; return 1 ; }
    DATE_CLI=$(which date) || { echo "ERROR: date not installed.  Please install date and re-run \"aws install\"." ; return 1 ; }
    REV_CLI=$(which rev) || { echo "ERROR: rev not installed.  Please install rev and re-run \"aws install\"." ; return 1 ; }
    CURL_CLI=$(which curl) || { echo "ERROR: curl not installed.  Please install curl and re-run \"aws install\"." ; return 1 ; }
    PIP3_CLI=$(which pip3) || { echo "ERROR: pip3 not installed.  Please install pip3 and re-run \"aws install\"." ; return 1 ; }
    CMP_CLI=$(which cmp) || { echo "ERROR: CMP not installed." ; return 1 ; }
    GETOPT_CLI=$(which getopt) ||
    {
        echo "ERROR: gnugetopt not installed.  Please install GNU getopt and re-run \"aws install\"."
        echo "If you are on Mac OSX, use brew to install \"gn--getopt\". https://formulae.brew.sh/formula/gnu-getopt"
        return 1
    }

    # Install aws-rotate-iam keys script from GitHub
    $CURL_CLI --fail -sS \
      https://raw.githubusercontent.com/rhyeal/aws-rotate-iam-keys/master/src/bin/aws-rotate-iam-keys \
      -o ${HOME}/.aws/cli/aws-rotate-iam-keys
    if [ -f  "${HOME}/.aws/cli/aws-rotate-iam-keys" ]; then
      echo "Downloaded https://raw.githubusercontent.com/rhyeal/aws-rotate-iam-keys/master/src/bin/aws-rotate-iam-keys"
    else
      echo "Unable to download https://raw.githubusercontent.com/rhyeal/aws-rotate-iam-keys/master/src/bin/aws-rotate-iam-keys"
      return 1
    fi
    $CHMOD_CLI a+x ${HOME}/.aws/cli/aws-rotate-iam-keys 2> /dev/null



    if [ -x ${HOME}/.aws/cli/aws-rotate-iam-keys ]; then
      echo "aws-rotate-iam-keys successfully installed"
    else
      echo "There was an error installing aws-rotate-iam-keys"
    fi

    # Install aws-mfa Python script using pip3
    $PIP3_CLI install --user --upgrade aws-mfa > /dev/null 2>&1

    AWS_MFA_CLI=$(which aws-mfa) ||
    {
      # Find the aws-mfa local binary in the usual places
      # Darwin/OSX typical location
      [ -d ${HOME}/Library ] && { AWS_MFA_SEARCH_PATH=$(echo ${AWS_MFA_SEARCH_PATH} ${HOME}/Library) ; }
      # Linux typical location
      [ -d ${HOME}/.local ] && { AWS_MFA_SEARCH_PATH=$(echo ${AWS_MFA_SEARCH_PATH} ${HOME}/.local) ; }
      # Look for the aws-mfa binary
      AWS_MFA_CLI=$($FIND_CLI ${AWS_MFA_SEARCH_PATH} -name aws-mfa -type f | $SORT_CLI -r | $HEAD_CLI -1 )
      [ -x $AWS_MFA_CLI ] && {
        echo "SUCCESS: aws-mfa installed and found at: $AWS_MFA_CLI"
      }
      [ -x $AWS_MFA_CLI ] || {
        echo "ERROR: aws-mfa not found."
        return 1
      }
    }

    # Update to the latest version of the aliases
    $CURL_CLI --fail -sS https://raw.githubusercontent.com/msaum/aws-alias/master/alias -o ${HOME}/.aws/cli/alias.$$
    if [ -f  "${HOME}/.aws/cli/alias.$$" ]; then
      echo "Downloaded https://raw.githubusercontent.com/msaum/aws-alias/master/alias"
    else
      echo "Unable to download https://raw.githubusercontent.com/msaum/aws-alias/master/alias"
      return 1
    fi
    if [ "$CMP_CLI ${HOME}/.aws/cli/alias ${HOME}/.aws/cli/alias.$$" ]; then
      echo "Files are different, updating ${HOME}/.aws/cli/alias"
      mv -f ${HOME}/.aws/cli/alias.$$ ${HOME}/.aws/cli/alias
    else
      echo "Files are are the same, not updating."
    fi

  }; f

# Rotate IAM long term credentials
# https://github.com/rhyeal/aws-rotate-iam-keys
rotate-iam-keys =
  !f() {
    [ "$1" ] && PROFILE=$1
    if [ -z ${PROFILE} ]; then
        echo "Your long term credentials must be provided as an argument."
        echo "If you are using MFA, you cannot use short term credentials to rotate long term credentials."
        echo "For example: use myprofile-long-term not myprofile"
        echo "Usage: aws rotate-iam-keys <profile-long-term>"
        return 1 ;
    else
        echo ${HOME}/.aws/cli/aws-rotate-iam-keys --profile "$PROFILE"
        ${HOME}/.aws/cli/aws-rotate-iam-keys --profile "$PROFILE"
    fi
    }; f

# Show the number of days remaining on your AWS credential
# Prerequisites:
# - Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws iam-keys-days-remaining
iam-keys-days-remaining =
  !f() {
    [ "$AWS_DEFAULT_PROFILE" ]  && PROFILE=$AWS_DEFAULT_PROFILE
    [ "$AWS_PROFILE" ]          && PROFILE=$AWS_PROFILE
    [ -z "${1}" ] && [ -z "$PROFILE" ] &&
      {
        echo "Can't determine your AWS Profile. Set AWS_PROFILE, or AWS_DEFAULT_PROFILE"
        echo "Usage: aws iam-keys-days-remaining"
        return 1
      }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." ; return 1 ; }
    SED_CLI=$(which sed) || { echo "ERROR: sed not installed." ; return 1 ; }
    GREP_CLI=$(which grep) || { echo "ERROR: grep not installed." ; return 1 ; }
    CUT_CLI=$(which cut) || { echo "ERROR: cut not installed." ; return 1 ; }
    DATE_CLI=$(which date) || { echo "ERROR: date not installed." ; return 1 ; }
    REV_CLI=$(which rev) || { echo "ERROR: rev not installed." ; return 1 ; }
    AWS_CLI=$(which aws) || { echo "ERROR: aws not installed." ; return 1 ; }
    UNAME_CLI=$(which uname) || { echo "ERROR: uname not installed." ; return 1 ; }

    # Set your aws username
    USERNAME=$($AWS_CLI sts get-caller-identity | $JQ_CLI .Arn | $SED_CLI 's/.*user\///g' | $SED_CLI 's/\"//g')

    # Get the aws create date for your key ..sample output "2021-02-26T14:41:05+00:00"
    CDATE=$($AWS_CLI iam list-access-keys --output json --user-name ${USERNAME} | $GREP_CLI CreateDate | $CUT_CLI -c 28- | $REV_CLI | $CUT_CLI -c 8- | $REV_CLI |  $SED_CLI -E s/T/\ /g)

    # Use CMPerent code based on the OS, since Darwin uses a CMPerent version of the date command
    [ $($UNAME_CLI) = "Darwin" ] &&  {
        # Get the aws create date for your key ..sample output "2021-02-26T14:41:05+00:00"
        CDATESTRING=$($DATE_CLI -jf "%Y-%m-%d %T" "${CDATE}")

        # Get the expiriation date by adding 60 days to the create date
        EXDATE=$($DATE_CLI -jf "%Y-%m-%d %T" -v +60d "${CDATE}" "+%s")

        # Calulate the number of days between today and the expiration date
        NOW=$($DATE_CLI "+%s")
        DAYSTOEXPIRE=$((($EXDATE - $NOW)/86400))
    }
    # Linux / GNU Code
    [ $($UNAME_CLI) = "Linux" ] && {
        # Get the expiriation date by adding 60 days to the create date
        EXDATE=$($DATE_CLI +"%s" -d"$($DATE_CLI +"%Y-%m-%d+60 days %T" -d"$CDATE")")

        # Calulate the number of days between today and the expiration date
        NOW=$($DATE_CLI +"%s")
        DAYSTOEXPIRE=$((($EXDATE - $NOW)/86400))
    }
    # Display to the user the number of days before the aws keys expire
    printf 'There are %d days left until your aws key expires\n' "${DAYSTOEXPIRE}"

    }; f

###########
### MFA ###
###########

# aws-mfa --duration 129600 --profile myprofile
# Prerequisites:
# - aws-mfa installed (https://pypi.org/project/aws-mfa/)
# - Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws mfa [profile]
mfa =
  !f() {
    SORT_CLI=$(which sort) || { echo "ERROR: sort not installed." ; return 1 ; }
    HEAD_CLI=$(which head) || { echo "ERROR: head not installed." ; return 1 ; }
    FIND_CLI=$(which find) || { echo "ERROR: find not installed." ; return 1 ; }

    [ "$AWS_DEFAULT_PROFILE" ]  && PROFILE=$AWS_DEFAULT_PROFILE
    [ "$AWS_PROFILE" ]          && PROFILE=$AWS_PROFILE

    AWS_MFA_CLI=$(which aws-mfa) ||
    {
      # Find the aws-mfa local binary in the usual places
      # Darwin/OSX typical location
      [ -d ${HOME}/Library ] && { AWS_MFA_SEARCH_PATH=$(echo ${AWS_MFA_SEARCH_PATH} ${HOME}/Library) ; }
      # Linux typical location
      [ -d ${HOME}/.local ] && { AWS_MFA_SEARCH_PATH=$(echo ${AWS_MFA_SEARCH_PATH} ${HOME}/.local) ; }
      # Look for the aws-mfa binary
      AWS_MFA_CLI=$($FIND_CLI ${AWS_MFA_SEARCH_PATH} -name aws-mfa -type f | $SORT_CLI -r | $HEAD_CLI -1 )
      [ -x $AWS_MFA_CLI ] && {
        echo "SUCCESS: aws-mfa installed and found at: $AWS_MFA_CLI"
      }
      [ -x $AWS_MFA_CLI ] || {
        echo "ERROR: aws-mfa not found."
        return 1
      }
    }

    [ "${1}" ]    && $AWS_MFA_CLI  --duration 129600 --profile $1
    [ -z "${1}" ] && [ -z "$PROFILE" ] &&
      {
        echo "Can't determine your AWS Profile. Set AWS_PROFILE, AWS_DEFAULT_PROFILE or use an argument."
        echo "Usage: aws mfa [profile]"
        return 1
      }
    [ -z "${1}" ] && $AWS_MFA_CLI  --duration 129600 --profile $PROFILE

  }; f

###########
### IAM ###
###########

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws whoami
whoami = sts get-caller-identity

create-assume-role =
  !f() {
    aws iam create-role --role-name "${1}" \
      --assume-role-policy-document \
        "{\"Statement\":[{\
            \"Action\":\"sts:AssumeRole\",\
            \"Effect\":\"Allow\",\
            \"Principal\":{\"Service\":\""${2}".amazonaws.com\"},\
            \"Sid\":\"\"\
          }],\
          \"Version\":\"2012-10-17\"\
        }";
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws find-access-key <access key>
# Note: If there are a lot of IAM users, this may take some time to run
find-access-key =
  !f() {
    clear_to_eol=$(tput el)
    for i in $(aws iam list-users --query "Users[].UserName" --output text); do
      printf "\r%sSearching...$i" "${clear_to_eol}"
      result=$(aws iam list-access-keys --output text --user-name "${i}" --query "AccessKeyMetadata[?AccessKeyId=='${1}'].UserName";)
      if [ -n "${result}" ]; then
         printf "\r%s%s is owned by %s.\n" "${lear_to_eol}" "$1" "${result}"
         break
      fi
    done
    if [ -z "${result}" ]; then
      printf "\r%sKey not found." "${clear_to_eol}"
    fi
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-iam-users
list-iam-users = iam list-users --query "Users[].UserName" --output table

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-user-keys <username>
list-user-keys =
  !f() {
    aws iam list-access-keys --output text --user-name "$1" --query "AccessKeyMetadata[].AccessKeyId";
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-virtual-mfa [username]
list-virtual-mfa =
  !f() {
    [ "${1}" ]    && aws iam list-mfa-devices --user-name ${1} | jq -r '.MFADevices[] | "Enabled: \(.EnableDate), ARN: \(.SerialNumber)"'
    [ -z "${1}" ] && aws iam list-mfa-devices | jq -r '.MFADevices[] | "Enabled: \(.EnableDate), ARN: \(.SerialNumber)"'
  }; f



# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws delete-virtual-mfa <username>
delete-virtual-mfa =
  !f() {
    account_id=$(aws sts get-caller-identity --output json | jq -r '.Account')
    aws iam delete-virtual-mfa-device--serial-number "arn:aws:iam::${account_id}:mfa/$1"
  }; f

# Find users without mfa
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Note: May have issue with large numbers of users due to AWS API throttling
# Usage: aws find-users-without-mfa
find-users-without-mfa =
  !f() {
    echo "Users withouth MFA enabled:"
    for i in $(aws iam list-users --query "Users[?PasswordLastUsed].UserName" --output text); do
      result=$(aws iam list-virtual-mfa-devices --query "length(VirtualMFADevices[?User.UserName=='${i}'])")
      if [ "${result}" -eq "0" ]; then
        echo "${i}"
      fi
    done
  }; f

generate-sts-token =
  !f() {
    user_arn=$(aws whoami | jq -r .Arn)
    duration=${1:-129600}
    session_data=$(aws sts get-session-token --duration-seconds $duration)
    echo "# temporary credentials on user ${user_arn} for $duration seconds (expires on $(echo $session_data | jq -r .Credentials.Expiration))"
    echo "export AWS_DEFAULT_REGION=$(aws configure get region)"
    echo "export AWS_ACCESS_KEY_ID=$(echo $session_data | jq -r .Credentials.AccessKeyId)"
    echo "export AWS_SECRET_ACCESS_KEY=$(echo $session_data | jq -r .Credentials.SecretAccessKey)"
    echo "export AWS_SESSION_TOKEN=$(echo $session_data | jq -r .Credentials.SessionToken)"
    echo "export AWS_SECURITY_TOKEN=$(echo $session_data | jq -r .Credentials.SessionToken)"
  }; f

assume =
  !f() {
    res=$(aws sts assume-role --role-arn ${1} --role-session-name session)
    if echo $res | grep -q AccessKeyId; then
        echo $res \
        | jq -r '
        "","[\(.Credentials.AccessKeyId)]",
        "aws_access_key_id     = \(.Credentials.AccessKeyId)",
        "aws_secret_access_key = \(.Credentials.SecretAccessKey)",
        "aws_session_token     = \(.Credentials.SessionToken)",
        "aws_security_token    = \(.Credentials.SessionToken)"
        ' \
        >> ${HOME}/.aws/credentials
        echo $res | jq -r '"AWS_PROFILE=\(.Credentials.AccessKeyId)"'
    fi
  }; f

###########
### EC2 ###
###########

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws running-instances
running-instances = ec2 describe-instances \
    --filter Name=instance-state-name,Values=running \
    --output table \
    --query 'Reservations[].Instances[].{ID: InstanceId,Hostname: PublicDnsName,Name: Tags[?Key==`Name`].Value | [0],Type: InstanceType, Platform: Platform || `Linux`}'

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws ebs-volumes
ebs-volumes= ec2 describe-volumes \
    --query 'Volumes[].{VolumeId: VolumeId,State: State,Size: Size,Name: Tags[0].Value,AZ: AvailabilityZone}' \
    --output table

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws amazon-linux-amis
amazon-linux-amis = ec2 describe-images \
    --filter \
      Name=owner-alias,Values=amazon \
      Name=name,Values="amzn-ami-hvm-*" \
      Name=architecture,Values=x86_64 \
      Name=virtualization-type,Values=hvm \
      Name=root-device-type,Values=ebs \
      Name=block-device-mapping.volume-type,Values=gp2 \
    --query "reverse(sort_by(Images, &CreationDate))[*].[ImageId,Name,Description]" \
    --output text

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-sgs
list-sgs = ec2 describe-security-groups --query "SecurityGroups[].[GroupId, GroupName]" --output text

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws sg-rules <security group id>
sg-rules =
  !f() {
  [ -z "${1}" ] &&
        {
          echo "Security group id not given"
          echo "Usage: aws sg-rules <security group id>"
          return 1
        }
    aws ec2 describe-security-groups \
    --query "SecurityGroups[].IpPermissions[].[FromPort,ToPort,IpProtocol,join(',',IpRanges[].CidrIp)]" \
    --group-id "$1" --output text;
  }; f

# Translates a security group name into a security group id
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: Usage: aws get-group-id <security group name>
get-group-id =
  !f() {
    [ -z "${1}" ] &&
          {
            echo "Security group name not given"
            echo "Usage: aws get-group-id <security group name>"
            return 1
          }
    aws ec2 describe-security-groups --filters Name=group-name,Values=${1} --query SecurityGroups[0].GroupId --output text
  }; f

authorize-my-ip-by-name =
  !f() {
    group_id=$(aws get-group-id "${1}")
    aws authorize-my-ip "$group_id"
  }; f

# list all security group port ranges open to 0.0.0.0/0
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws public-ports
public-ports = ec2 describe-security-groups \
  --filters Name=ip-permission.cidr,Values=0.0.0.0/0 \
  --query 'SecurityGroups[].{
    GroupName:GroupName,
    GroupId:GroupId,
    PortRanges:
      IpPermissions[?contains(IpRanges[].CidrIp, `0.0.0.0/0`)].[
        join(`:`, [IpProtocol, join(`-`, [to_string(FromPort), to_string(ToPort)])])
      ][]
  }'

# Show my current external ip address
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws myip
myip =
  !f() {
    curl https://checkip.amazonaws.com
  }; f

#allow-my-ip =
  !f() {
    my_ip=$(aws myip)
    aws ec2 authorize-security-group-ingress --group-name ${1} --protocol ${2} --port ${3} --cidr $my_ip/32
  }; f

#revoke-my-ip =
  !f() {
    my_ip=$(aws myip)
    aws ec2 revoke-security-group-ingress --group-name ${1} --protocol ${2} --port ${3} --cidr $my_ip/32
  }; f

#allow-my-ip-all =
  !f() {
    aws allow-my-ip ${1} all all
  }; f

#revoke-my-ip-all =
  !f() {
    aws revoke-my-ip ${1} all all
  }; f

# Delete an AMI
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws delete-ami <AMI ID>
delete-ami =
  !f() {
    [ -z "${1}" ] &&
          {
            echo "AMI ID not given"
            echo "Usage: aws delete-ami <AMI ID>"
            return 1
          }
    snapshots=($(aws ec2 describe-images --image-ids $1 --query "Images[].BlockDeviceMappings[].Ebs.SnapshotId" --output text))
    aws ec2 deregister-image --image-id $1
    for id in $snapshots
    do
      aws ec2 delete-snapshot --snapshot-id ${id}
    done
  }; f

list-instances =
  !f() {
    echo "Filtering by \`$1\`"
    for region in $(aws ec2 describe-regions --query "Regions[*].RegionName" --output text | tr "\t" "\n" | grep "$1")
      do
        echo "\nListing Instances in region:'$region'..."
        aws ec2 describe-instances --region $region \
        --output table \
        --query "Reservations[*].Instances[*].{
                Instance:InstanceId,
                Type:InstanceType,
                AZ:Placement.AvailabilityZone,
                KeyName:KeyName,
                Name:Tags[?Key==\`Name\`]|[0].Value,
                Project:Tags[?Key==\`project\`]|[0].Value,
                IP:PublicIpAddress,
                State:State.Name,
                CPUcores:CpuOptions.CoreCount,
                CPUThreads:CpuOptions.ThreadsPerCore
        }"
      done
  }; f

connect-ssh =
  !f() {
    instance_output=$(aws ec2 describe-instances \
                        --instance-ids "${1}" \
                        --query Reservations[0].Instances[0])
    ssh_key_file=$(jp -u KeyName <<< "$instance_output")".pem"
    public_ip=$(jp -u PublicIpAddress <<< "$instance_output")
    if ! [ -f "$ssh_key_file" ];
    then
      echo "Error: Could not locate SSH key: "$ssh_key_file" in current" \
           "working direcory"
      exit 1
    fi
    if [ "$public_ip" == "null" ];
    then
      echo "EC2 Instance: "${1}" does not have a public IP address." \
           "Unable to connect with SSH."
      exit 1
    fi
    ssh -i "$ssh_key_file" ec2-user@"$public_ip"
  }; f

search-instances =
  !f() {
    aws ec2 describe-instances \
    --filters Name=instance-state-name,Values=running,stopped \
    --query "Reservations[].Instances[].{Name: (Tags[?Key==\`Name\`].Value)[0],
                                        Id: InstanceId,
                                        PrivateIpAddress: PrivateIpAddress,
                                        GroupId: SecurityGroups[].GroupId|join(\`,\`,@)}[?contains(Name,\`"${1}"\`)]" \
    --out table
  }; f

list-all-regions =
  !f() {
    aws ec2 describe-regions --query "Regions[].RegionName" --output text
  }; f

list-azs =
  !f() {
    aws ec2 describe-availability-zones --region $1 --query AvailabilityZones[].ZoneName --output text;
  }; f

vpc-peers =
  !f() {
    aws ec2 describe-vpc-peering-connections \
    --query 'VpcPeeringConnections[].Tags[?Key==`Name`].Value' --output text | xargs -n1 | sort -d
  }; f

find-instances-in-sg =
  !f() {
    filter=${2:-Name}
    for i in $(aws ec2 describe-instances --filters "Name=network-interface.group-id,Values=['${1}']" --query "Reservations[].Instances[].Tags[?Key == '${filter}'].Value[]" --output text)
    do
      echo ${i}
    done
  }; f

find-ssh-open = ec2 describe-security-groups \
  --filters Name=ip-permission.from-port,Values=22 \
  --query "SecurityGroups[].{
    GroupName: GroupName,
    GroupId: GroupId,
    IPs: IpPermissions[?to_string(FromPort) == '22'][IpRanges[].CidrIp][][]
  }"

get-asg-instance-ips =
  !f() {
    asg_name=${1}
    aws ec2 describe-instances --filters "Name=tag:aws:autoscaling:groupName,Values=${asg_name}" | jq -r '.Reservations[].Instances[].PrivateIpAddress'
  }; f

find-host-by-instance-id =
  !f() {
    instance_id=${1}
    aws ec2 describe-instances --filters "Name=instance-id,Values=${instance_id}" | jq -r '.Reservations[].Instances[].PrivateIpAddress' | sed -E 's/\./-/g; s/^/ip-/'
  }; f

find-instance-by-public-ip =
  !f() {
    aws ec2 describe-instances --filters "Name=ip-address,Values=$1" | jq -r '.Reservations[].Instances[].Tags[] | select(.Key == "Name").Value'
  }; f

find-nat-gateway-by-public-ip =
  !f() {
    aws ec2 describe-nat-gateways | jq -r '.NatGateways[] | select(.NatGatewayAddresses[].PublicIp == "'$1'") | .Tags[] | select(.Key == "Name").Value'
  }; f

list-igw = ec2 describe-internet-gateways \
    --query "InternetGateways[].{IGW:InternetGatewayId,VpcId: Attachments[].VpcId|[0], Name: Tags[?Key=='Name'].Value |[0] }"  \
    --output table

list-ngw = ec2 describe-nat-gateways \
    --query "NatGateways[].{VpcId:VpcId, NatGatewayId: NatGatewayId, SubnetId: SubnetId, PublicIp: NatGatewayAddresses[].PublicIp | [0], PrivateIp: NatGatewayAddresses[].PrivateIp | [0] }" \
    --output table

list-vgw = ec2 describe-vpn-gateways \
    --query "VpnGateways[].{VpnGatewayId: VpnGatewayId, AmazonSideAsn: AmazonSideAsn, VpcId: VpcAttachments.VpcId,Name: Tags[?Key=='Name'].Value| [0] }" \
    --output table

list-vpn-connection = ec2 describe-vpn-connections \
    --query "VpnConnections[].{ VpnConnectionId: VpnConnectionId, CustomerGatewayId:CustomerGatewayId,VpnGatewayId:VpnGatewayId, Name: Tags[?Key=='Name'].Value| [0] }" \
    --output table

list-instance-status = ec2 describe-instance-status \
    --query "InstanceStatuses[].{InstanceId: InstanceId, State: InstanceState.Name, AZ: AvailabilityZone, SystemStatus: SystemStatus.Status, InstanceStatus: InstanceStatus.Status}" \
    --output table

list-vpcs = ec2 describe-vpcs \
      --query \
        "Vpcs[].{VpcId: VpcId, CidrBlock: CidrBlock,  Name: Tags[?Key=='Name'].Value| [0], IsDefault: IsDefault}" \
      --output table

list-subnets = ec2 describe-subnets \
    --query "Subnets[].{AZ:AvailabilityZone,VpcId:VpcId,SubnetId:SubnetId,CidrBlock:CidrBlock,    Name: Tags[?Key=='Name'].Value| [0]}" \
    --output table

list-routes = ec2 describe-route-tables \
  --query "RouteTables[].{RouteTableId:RouteTableId, VpcId:VpcId, Name: Tags[?Key=='Name'].Value| [0], GatewayId: Routes[].{GatewayId:GatewayId,DestinationCidrBlock: DestinationCidrBlock} }  " \
  --output table

get-dns-from-instance-id =
  !f() {
    aws ec2 describe-instances \
    --instance-ids "${1}" \
    --query 'Reservations[*].Instances[*][PublicDnsName,InstanceId]' --output text | cut -f1
  }; f

get-instance-id-from-dns =
  !f() {
    aws ec2 describe-instances \
    --filters "Name=dns-name,Values=${1}" \
    --query 'Reservations[*].Instances[*][InstanceId,PublicDnsName]' --output text | cut -f1
  }; f

################
## Cloudwatch ##
################

last-log =
  !f() {
    group="$1"

    if ! stream="$(aws logs describe-log-streams --log-group-name "$group" \
    --max-items 1 --order-by LastEventTime --descending \
    --query "logStreams[0].logStreamName" --output "text")"; then
        return 1
    fi

    stream="${stream%[[:space:]]None}"

    aws logs get-log-events --log-group-name "$group" --log-stream-name "$stream" \
    --query "events[].message" --output "text"
  }; f

##########
## ECR ###
##########

docker-ecr-login =
  !f() {
    region=$(aws configure get region)
    endpoint=$(aws ecr get-authorization-token --region $region --output text --query authorizationData[].proxyEndpoint)
    passwd=$(aws ecr get-authorization-token --region $region --output text --query authorizationData[].authorizationToken | base64 --decode | cut -d: -f2)
    docker login -u AWS -p $passwd $endpoint
  }; f


