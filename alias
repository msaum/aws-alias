[toplevel]

###############
### GENERAL ###
###############

## Shortcuts
ag = apigateway
as = autoscaling
cfn = cloudformation
cp = codepipeline
ddb = dynamodb
eb = elasticbeanstalk
ec = elasticache
sc = servicecatalog
sg = security-group

tostring =
  !f() {
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." ; return 1 ; }
    cat "${1}" | jq 'tostring'
  }; f

# List or set your region
# Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws region [region]
region =
  !f() {
    [ $# -eq 1 ] && aws configure set region "$1" || aws configure get region;
  }; f

# List or set your region
# Usage: aws profiles
profiles =
  !f() {
    echo "export AWS_DEFAULT_PROFILE= to set a default profile."
    echo "Currently: AWS_DEFAULT_PROFILE=$AWS_DEFAULT_PROFILE"
    aws configure list-profiles
  }; f

# Upgrade to the latest version of the AWS CLI v2
# Usage: aws upgrade
upgrade =
  !f() {
    CURL_CLI=$(which curl) || { echo "ERROR: curl not installed." ; return 1 ; }
    UNZIP_CLI=$(which unzip) || { echo "ERROR: unzip not installed." ; return 1 ; }
    CUT_CLI=$(which cut) || { echo "ERROR: cut not installed." ; return 1 ; }
    SUDO_CLI=$(which sudo) || { echo "ERROR: sudo not installed." ; return 1 ; }
    echo OSTYPE=$OSTYPE
		[ "$OSTYPE" = "darwin"* ] &&  {
		  echo "OS: OSX / Darwin"
	    echo "Current version: $(aws --version | $CUT_CLI -d' ' -f 1)"
	    echo "Downloading AWS CLI v2..."
	    $CURL_CLI --no-progress-meter "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "/tmp/AWSCLIV2.pkg"
      $SUDO_CLI installer -pkg /tmp/AWSCLIV2.pkg -target /
      rm -f /tmp/AWSCLIV2.pkg 2> /dev.null
	    echo "New version: $(aws --version | $CUT_CLI -d' ' -f 1)"
		}
		[ $(uname -o) = "GNU/Linux" ] && {
		  echo "OS: GNU/Linux"
		  rm -f /tmp/awscliv2.zip 2> /dev/null
		  rm -rf /tmp/aws/ 2> /dev/null
	    echo "Downloading AWS CLI v2..."
	    $CURL_CLI --no-progress-meter "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
	    $(cd /tmp && $UNZIP_CLI awscliv2.zip && rm -f /tmp/awscliv2.zip) 2> /dev/null
	    echo "Current version: $(aws --version | $CUT_CLI -d' ' -f 1)"
	    echo "    New version: $(/tmp/aws/dist/aws --version | $CUT_CLI -d' ' -f 1)"
	    $SUDO_CLI /tmp/aws/install --update
		  rm -rf /tmp/aws/ 2> /dev/null
		}
  }; f

# Usage: aws check-upgrade
check-upgrade =
  !f() {
  	CURL_CLI=$(which curl) || { echo "ERROR: curl not installed." ; return 1 ; }
  	TAR_CLI=$(which tar) || { echo "ERROR: tar not installed." ; return 1 ; }
    UNZIP_CLI=$(which unzip) || { echo "ERROR: unzip not installed." ; return 1 ; }
    SED_CLI=$(which sed) || { echo "ERROR: sed not installed." ; return 1 ; }
    GREP_CLI=$(which grep) || { echo "ERROR: grep not installed." ; return 1 ; }
    CUT_CLI=$(which cut) || { echo "ERROR: cut not installed." ; return 1 ; }
    TR_CLI=$(which tr) || { echo "ERROR: tr not installed." ; return 1 ; }
		[ "$OSTYPE" = "darwin"* ] &&  {
		  echo "OS: OSX / Darwin"
	    rm -f /tmp/AWSCLIV2.pkg
	    echo "Downloading AWS CLI v2..."
	    latest_cli_version=$($CURL_CLI --no-progress-meter "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o - | \
	    $TAR_CLI xOv - 2>/dev/null | \
	    $GREP_CLI -a '<pkg-info' | \
	    $SED_CLI "s#.* version=\"\([0-9\.]*\)\".*#\1#")
	    release_date=$($CURL_CLI -sI "https://awscli.amazonaws.com/AWSCLIV2.pkg" | \
	        $GREP_CLI 'Last-Modified' | $CUT_CLI -d':' -f 2- | $TR_CLI '\r\n' ' ')
	    echo "Current version: $(aws --version | $CUT_CLI -d' ' -f 1)"
	    echo "    New version: aws-cli/${latest_cli_version} (${release_date})"
		}
		[ $(uname -o) = "GNU/Linux" ] && {
		  echo "OS: GNU/Linux"
	    echo "Downloading AWS CLI v2..."
	    $CURL_CLI --no-progress-meter "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
	    $(cd /tmp && $UNZIP_CLI awscliv2.zip && rm -f /tmp/awscliv2.zip) 2> /dev/null
	    echo "Current version: $(aws --version | $CUT_CLI -d' ' -f 1)"
      echo "    New version: $(/tmp/aws/dist/aws --version | $CUT_CLI -d' ' -f 1)"
		  rm -rf /tmp/aws/ 2> /dev/null
		}
  }; f


###########
### MFA ###
###########

# aws-mfa --duration 129600 --profile aws-hhs-cms-tms
# Prerequisites:
# - aws-mfa installed
# - Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws mfa [profile]
mfa =
  !f() {
    [ "$AWS_DEFAULT_PROFILE" ]  && PROFILE=$AWS_DEFAULT_PROFILE
    [ "$AWS_PROFILE" ]          && PROFILE=$AWS_PROFILE
    AWS_MFA_CLI=$(which aws-mfa) || { echo "ERROR: aws-mfa not installed." ; return 1 ; }

    [ "${1}" ]    && $AWS_MFA_CLI  --duration 129600 --profile $1
    [ -z "${1}" ] && [ -z "$PROFILE" ] &&
      {
        echo "Can't determine your AWS Profile. Set AWS_PROFILE, AWS_DEFAULT_PROFILE or use an argument."
        echo "Usage: aws mfa [profile]"
        return 1
      }
    [ -z "${1}" ] && $AWS_MFA_CLI  --duration 129600 --profile $PROFILE

  }; f


###########
### IAM ###
###########

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws whoami
whoami = sts get-caller-identity

#create-assume-role =
#  !f() {
#    aws iam create-role --role-name "${1}" \
#      --assume-role-policy-document \
#        "{\"Statement\":[{\
#            \"Action\":\"sts:AssumeRole\",\
#            \"Effect\":\"Allow\",\
#            \"Principal\":{\"Service\":\""${2}".amazonaws.com\"},\
#            \"Sid\":\"\"\
#          }],\
#          \"Version\":\"2012-10-17\"\
#        }";
#  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws find-access-key <access key>
# Note: If there are a lot of IAM users, this may take some time to run
find-access-key =
  !f() {
    clear_to_eol=$(tput el)
    for i in $(aws iam list-users --query "Users[].UserName" --output text); do
      printf "\r%sSearching...$i" "${clear_to_eol}"
      result=$(aws iam list-access-keys --output text --user-name "${i}" --query "AccessKeyMetadata[?AccessKeyId=='${1}'].UserName";)
      if [ -n "${result}" ]; then
         printf "\r%s%s is owned by %s.\n" "${lear_to_eol}" "$1" "${result}"
         break
      fi
    done
    if [ -z "${result}" ]; then
      printf "\r%sKey not found." "${clear_to_eol}"
    fi
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-iam-users
list-iam-users = iam list-users --query "Users[].UserName" --output table

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-user-keys <username>
list-user-keys =
  !f() {
    aws iam list-access-keys --output text --user-name "$1" --query "AccessKeyMetadata[].AccessKeyId";
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-virtual-mfa [username]
list-virtual-mfa =
  !f() {
    [ "${1}" ]    && aws iam list-mfa-devices --user-name ${1} | jq -r '.MFADevices[] | "Enabled: \(.EnableDate), ARN: \(.SerialNumber)"'
    [ -z "${1}" ] && aws iam list-mfa-devices | jq -r '.MFADevices[] | "Enabled: \(.EnableDate), ARN: \(.SerialNumber)"'
  }; f



# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws delete-virtual-mfa <username>
delete-virtual-mfa =
  !f() {
    account_id=$(aws sts get-caller-identity --output json | jq -r '.Account')
    aws iam delete-virtual-mfa-device--serial-number "arn:aws:iam::${account_id}:mfa/$1"
  }; f

# Find users without mfa
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Note: May have issue with large numbers of users due to AWS API throttling
# Usage: find-users-without-mfa
find-users-without-mfa =
  !f() {
    echo "Users withouth MFA enabled:"
    for i in $(aws iam list-users --query "Users[?PasswordLastUsed].UserName" --output text); do
      result=$(aws iam list-virtual-mfa-devices --query "length(VirtualMFADevices[?User.UserName=='${i}'])")
      if [ "${result}" -eq "0" ]; then
        echo "${i}"
      fi
    done
  }; f

#generate-sts-token =
#  !f() {
#    user_arn=$(aws whoami | jq -r .Arn)
#    duration=${1:-129600}
#    session_data=$(aws sts get-session-token --duration-seconds $duration)
#    echo "# temporary credentials on user ${user_arn} for $duration seconds (expires on $(echo $session_data | jq -r .Credentials.Expiration))"
#    echo "export AWS_DEFAULT_REGION=$(aws configure get region)"
#    echo "export AWS_ACCESS_KEY_ID=$(echo $session_data | jq -r .Credentials.AccessKeyId)"
#    echo "export AWS_SECRET_ACCESS_KEY=$(echo $session_data | jq -r .Credentials.SecretAccessKey)"
#    echo "export AWS_SESSION_TOKEN=$(echo $session_data | jq -r .Credentials.SessionToken)"
#    echo "export AWS_SECURITY_TOKEN=$(echo $session_data | jq -r .Credentials.SessionToken)"
#  }; f

#assume =
#  !f() {
#    res=$(aws sts assume-role --role-arn ${1} --role-session-name session)
#    if echo $res | grep -q AccessKeyId; then
#        echo $res \
#        | jq -r '
#        "","[\(.Credentials.AccessKeyId)]",
#        "aws_access_key_id     = \(.Credentials.AccessKeyId)",
#        "aws_secret_access_key = \(.Credentials.SecretAccessKey)",
#        "aws_session_token     = \(.Credentials.SessionToken)",
#        "aws_security_token    = \(.Credentials.SessionToken)"
#        ' \
#        >> ~/.aws/credentials
#        echo $res | jq -r '"AWS_PROFILE=\(.Credentials.AccessKeyId)"'
#    fi
#  }; f

###########
### EC2 ###
###########

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
running-instances = ec2 describe-instances \
    --filter Name=instance-state-name,Values=running \
    --output table \
    --query 'Reservations[].Instances[].{ID: InstanceId,Hostname: PublicDnsName,Name: Tags[?Key==`Name`].Value | [0],Type: InstanceType, Platform: Platform || `Linux`}'

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
ebs-volumes= ec2 describe-volumes \ZZ
    --query 'Volumes[].{VolumeId: VolumeId,State: State,Size: Size,Name: Tags[0].Value,AZ: AvailabilityZone}' \
    --output table

amazon-linux-amis = ec2 describe-images \
    --filter \
      Name=owner-alias,Values=amazon \
      Name=name,Values="amzn-ami-hvm-*" \
      Name=architecture,Values=x86_64 \
      Name=virtualization-type,Values=hvm \
      Name=root-device-type,Values=ebs \
      Name=block-device-mapping.volume-type,Values=gp2 \
    --query "reverse(sort_by(Images, &CreationDate))[*].[ImageId,Name,Description]" \
    --output text

list-sgs = ec2 describe-security-groups --query "SecurityGroups[].[GroupId, GroupName]" --output text

sg-rules =
  !f() {
    aws ec2 describe-security-groups \
    --query "SecurityGroups[].IpPermissions[].[FromPort,ToPort,IpProtocol,join(',',IpRanges[].CidrIp)]" \
    --group-id "$1" --output text;
  }; f

get-group-id =
  !f() {
    aws ec2 describe-security-groups --filters Name=group-name,Values=${1} --query SecurityGroups[0].GroupId --output text
  }; f

authorize-my-ip-by-name =
  !f() {
    group_id=$(aws get-group-id "${1}")
    aws authorize-my-ip "$group_id"
  }; f

# list all security group port ranges open to 0.0.0.0/0
public-ports = ec2 describe-security-groups \
  --filters Name=ip-permission.cidr,Values=0.0.0.0/0 \
  --query 'SecurityGroups[].{
    GroupName:GroupName,
    GroupId:GroupId,
    PortRanges:
      IpPermissions[?contains(IpRanges[].CidrIp, `0.0.0.0/0`)].[
        join(`:`, [IpProtocol, join(`-`, [to_string(FromPort), to_string(ToPort)])])
      ][]
  }'

myip =
  !f() {
    curl https://checkip.amazonaws.com
  }; f

allow-my-ip =
  !f() {
    my_ip=$(aws myip)
    aws ec2 authorize-security-group-ingress --group-name ${1} --protocol ${2} --port ${3} --cidr $my_ip/32
  }; f

revoke-my-ip =
  !f() {
    my_ip=$(aws myip)
    aws ec2 revoke-security-group-ingress --group-name ${1} --protocol ${2} --port ${3} --cidr $my_ip/32
  }; f

allow-my-ip-all =
  !f() {
    aws allow-my-ip ${1} all all
  }; f

revoke-my-ip-all =
  !f() {
    aws revoke-my-ip ${1} all all
  }; f

delete-ami =
  !f() {
    snapshots=($(aws ec2 describe-images --image-ids $1 --query "Images[].BlockDeviceMappings[].Ebs.SnapshotId" --output text))
    aws ec2 deregister-image --image-id $1
    for id in $snapshots
    do
      aws ec2 delete-snapshot --snapshot-id ${id}
    done
  }; f

list-instances =
  !f() {
    echo "Filtering by \`$1\`"
    for region in $(aws ec2 describe-regions --query "Regions[*].RegionName" --output text | tr "\t" "\n" | grep "$1")
      do
        echo "\nListing Instances in region:'$region'..."
        aws ec2 describe-instances --region $region \
        --output table \
        --query "Reservations[*].Instances[*].{
                Instance:InstanceId,
                Type:InstanceType,
                AZ:Placement.AvailabilityZone,
                KeyName:KeyName,
                Name:Tags[?Key==\`Name\`]|[0].Value,
                Project:Tags[?Key==\`project\`]|[0].Value,
                IP:PublicIpAddress,
                State:State.Name,
                CPUcores:CpuOptions.CoreCount,
                CPUThreads:CpuOptions.ThreadsPerCore
        }"
      done
  }; f

connect-ssh =
  !f() {
    instance_output=$(aws ec2 describe-instances \
                        --instance-ids "${1}" \
                        --query Reservations[0].Instances[0])
    ssh_key_file=$(jp -u KeyName <<< "$instance_output")".pem"
    public_ip=$(jp -u PublicIpAddress <<< "$instance_output")
    if ! [ -f "$ssh_key_file" ];
    then
      echo "Error: Could not locate SSH key: "$ssh_key_file" in current" \
           "working direcory"
      exit 1
    fi
    if [ "$public_ip" == "null" ];
    then
      echo "EC2 Instance: "${1}" does not have a public IP address." \
           "Unable to connect with SSH."
      exit 1
    fi
    ssh -i "$ssh_key_file" ec2-user@"$public_ip"
  }; f

search-instances =
  !f() {
    aws ec2 describe-instances \
    --filters Name=instance-state-name,Values=running,stopped \
    --query "Reservations[].Instances[].{Name: (Tags[?Key==\`Name\`].Value)[0],
                                        Id: InstanceId,
                                        PrivateIpAddress: PrivateIpAddress,
                                        GroupId: SecurityGroups[].GroupId|join(\`,\`,@)}[?contains(Name,\`"${1}"\`)]" \
    --out table
  }; f

list-all-regions =
  !f() {
    aws ec2 describe-regions --query "Regions[].RegionName" --output text
  }; f

list-azs =
  !f() {
    aws ec2 describe-availability-zones --region $1 --query AvailabilityZones[].ZoneName --output text;
  }; f

vpc-peers =
  !f() {
    aws ec2 describe-vpc-peering-connections \
    --query 'VpcPeeringConnections[].Tags[?Key==`Name`].Value' --output text | xargs -n1 | sort -d
  }; f

find-instances-in-sg =
  !f() {
    filter=${2:-Name}
    for i in $(aws ec2 describe-instances --filters "Name=network-interface.group-id,Values=['${1}']" --query "Reservations[].Instances[].Tags[?Key == '${filter}'].Value[]" --output text)
    do
      echo ${i}
    done
  }; f

find-ssh-open = ec2 describe-security-groups \
  --filters Name=ip-permission.from-port,Values=22 \
  --query "SecurityGroups[].{
    GroupName: GroupName,
    GroupId: GroupId,
    IPs: IpPermissions[?to_string(FromPort) == '22'][IpRanges[].CidrIp][][]
  }"

get-asg-instance-ips =
  !f() {
    asg_name=${1}
    aws ec2 describe-instances --filters "Name=tag:aws:autoscaling:groupName,Values=${asg_name}" | jq -r '.Reservations[].Instances[].PrivateIpAddress'
  }; f

find-host-by-instance-id =
  !f() {
    instance_id=${1}
    aws ec2 describe-instances --filters "Name=instance-id,Values=${instance_id}" | jq -r '.Reservations[].Instances[].PrivateIpAddress' | sed -E 's/\./-/g; s/^/ip-/'
  }; f

find-instance-by-public-ip =
  !f() {
    aws ec2 describe-instances --filters "Name=ip-address,Values=$1" | jq -r '.Reservations[].Instances[].Tags[] | select(.Key == "Name").Value'
  }; f

find-nat-gateway-by-public-ip =
  !f() {
    aws ec2 describe-nat-gateways | jq -r '.NatGateways[] | select(.NatGatewayAddresses[].PublicIp == "'$1'") | .Tags[] | select(.Key == "Name").Value'
  }; f

list-igw = ec2 describe-internet-gateways \
    --query "InternetGateways[].{IGW:InternetGatewayId,VpcId: Attachments[].VpcId|[0], Name: Tags[?Key=='Name'].Value |[0] }"  \
    --output table

list-ngw = ec2 describe-nat-gateways \
    --query "NatGateways[].{VpcId:VpcId, NatGatewayId: NatGatewayId, SubnetId: SubnetId, PublicIp: NatGatewayAddresses[].PublicIp | [0], PrivateIp: NatGatewayAddresses[].PrivateIp | [0] }" \
    --output table

list-vgw = ec2 describe-vpn-gateways \
    --query "VpnGateways[].{VpnGatewayId: VpnGatewayId, AmazonSideAsn: AmazonSideAsn, VpcId: VpcAttachments.VpcId,Name: Tags[?Key=='Name'].Value| [0] }" \
    --output table

list-vpn-connection = ec2 describe-vpn-connections \
    --query "VpnConnections[].{ VpnConnectionId: VpnConnectionId, CustomerGatewayId:CustomerGatewayId,VpnGatewayId:VpnGatewayId, Name: Tags[?Key=='Name'].Value| [0] }" \
    --output table

list-instance-status = ec2 describe-instance-status \
    --query "InstanceStatuses[].{InstanceId: InstanceId, State: InstanceState.Name, AZ: AvailabilityZone, SystemStatus: SystemStatus.Status, InstanceStatus: InstanceStatus.Status}" \
    --output table

list-vpcs = ec2 describe-vpcs \
      --query \
        "Vpcs[].{VpcId: VpcId, CidrBlock: CidrBlock,  Name: Tags[?Key=='Name'].Value| [0], IsDefault: IsDefault}" \
      --output table

list-subnets = ec2 describe-subnets \
    --query "Subnets[].{AZ:AvailabilityZone,VpcId:VpcId,SubnetId:SubnetId,CidrBlock:CidrBlock,    Name: Tags[?Key=='Name'].Value| [0]}" \
    --output table

list-routes = ec2 describe-route-tables \
  --query "RouteTables[].{RouteTableId:RouteTableId, VpcId:VpcId, Name: Tags[?Key=='Name'].Value| [0], GatewayId: Routes[].{GatewayId:GatewayId,DestinationCidrBlock: DestinationCidrBlock} }  " \
  --output table

get-dns-from-instance-id =
  !f() {
    aws ec2 describe-instances \
    --instance-ids "${1}" \
    --query 'Reservations[*].Instances[*][PublicDnsName,InstanceId]' --output text | cut -f1
  }; f

get-instance-id-from-dns =
  !f() {
    aws ec2 describe-instances \
    --filters "Name=dns-name,Values=${1}" \
    --query 'Reservations[*].Instances[*][InstanceId,PublicDnsName]' --output text | cut -f1
  }; f

################
## Cloudwatch ##
################

last-log =
  !f() {
    group="$1"

    if ! stream="$(aws logs describe-log-streams --log-group-name "$group" \
    --max-items 1 --order-by LastEventTime --descending \
    --query "logStreams[0].logStreamName" --output "text")"; then
        return 1
    fi

    stream="${stream%[[:space:]]None}"

    aws logs get-log-events --log-group-name "$group" --log-stream-name "$stream" \
    --query "events[].message" --output "text"
  }; f

##########
## ECR ###
##########

docker-ecr-login =
  !f() {
    region=$(aws configure get region)
    endpoint=$(aws ecr get-authorization-token --region $region --output text --query authorizationData[].proxyEndpoint)
    passwd=$(aws ecr get-authorization-token --region $region --output text --query authorizationData[].authorizationToken | base64 --decode | cut -d: -f2)
    docker login -u AWS -p $passwd $endpoint
  }; f