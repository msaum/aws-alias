#!/usr/bin/env bash
[toplevel]

# AWS CLI v2 Return Codes
# https://awscli.amazonaws.com/v2/documentation/api/latest/topic/return-codes.html
###############
### GENERAL ###
###############

## Shortcuts
ag = apigateway
as = autoscaling
cfn = cloudformation
cp = codepipeline
ddb = dynamodb
eb = elasticbeanstalk
ec = elasticache
sc = servicecatalog
sg = security-group
sh = securityhub

tostring =
  !f() {
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed."  1>&2 ; return 1 ; }
    cat "${1}" | ${JQ_CLI} 'tostring'
  }; f

# List or set your region
# Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws region [region]
region =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path."  1>&2 ; return 1 ; }
    [ $# -eq 1 ] && ${AWS_CLI} configure set region "$1" || ${AWS_CLI} configure get region;
  }; f

# List or set your region
# Usage: aws profiles
profiles =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path."  1>&2 ; return 1 ; }
    echo "export AWS_DEFAULT_PROFILE= to set a default profile."
    echo "Currently: AWS_DEFAULT_PROFILE=$AWS_DEFAULT_PROFILE"
    ${AWS_CLI} configure list-profiles
    return 0
  }; f

# Upgrade to the latest version of the AWS CLI v2
# Usage: aws upgrade
upgrade =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path."  1>&2 ; return 1 ; }
    CURL_CLI=$(which curl) || { echo "ERROR: curl not installed."  1>&2 ; return 1 ; }
    UNZIP_CLI=$(which unzip) || { echo "ERROR: unzip not installed."  1>&2 ; return 1 ; }
    CUT_CLI=$(which cut) || { echo "ERROR: cut not installed."  1>&2 ; return 1 ; }
    SUDO_CLI=$(which sudo) || { echo "ERROR: sudo not installed."  1>&2 ; return 1 ; }
    UNAME_CLI=$(which uname) || { echo "ERROR: uname not installed."  1>&2 ; return 1 ; }

    [ $($UNAME_CLI) = "Darwin" ] &&  {
	    echo "OS: OSX / Darwin"
	    echo "Current version: $(${AWS_CLI} --version | $CUT_CLI -d' ' -f 1)"
	    echo "Downloading AWS CLI v2..."
      $CURL_CLI --fail -sS https://awscli.amazonaws.com/AWSCLIV2.pkg -o /tmp/AWSCLIV2.pkg
      if [ ! -f  "/tmp/AWSCLIV2.pkg" ]; then
        echo "ERROR: Unable to download: https://awscli.amazonaws.com/AWSCLIV2.pkg"  1>&2
        return 1
      fi
      $SUDO_CLI installer -pkg /tmp/AWSCLIV2.pkg -target /
      rm -f /tmp/AWSCLIV2.pkg 2> /dev.null
	    echo "    New version $(aws --version | $CUT_CLI -d' ' -f 1)"
    }
    [ $($UNAME_CLI) = "Linux" ] && {
      echo "OS: Linux"
		  rm -f /tmp/awscliv2.zip 2> /dev/null
		  rm -rf /tmp/aws/ 2> /dev/null
	    echo "Downloading AWS CLI v2..."
	    $CURL_CLI --fail -sS "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
      if [ ! -f  "/tmp/awscliv2.zip" ]; then
        echo "ERROR: Unable to download: https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"  1>&2
        return 1
      fi
	    $(cd /tmp && $UNZIP_CLI awscliv2.zip && rm -f /tmp/awscliv2.zip) 2> /dev/null
	    CURRENT_VER=$(${AWS_CLI} --version | $CUT_CLI -d' ' -f 1)
	    NEW_VER=$(/tmp/aws/dist/aws --version | $CUT_CLI -d' ' -f 1)
	    echo "Current version: $CURRENT_VER"
	    echo "    New version: $NEW_VER"
	    if [ "${CURRENT_VER}" = "${NEW_VER}" ]; then
	      echo "Versions are the same, no changes."
	    else
  	    $SUDO_CLI /tmp/aws/install --update
      fi
		  rm -rf /tmp/aws/ 2> /dev/null
		}
  }; f

# Check for the latest version of the AWS CLI v2
# Usage: aws check-upgrade
# Removed, since it takes about the same amount to just upgrade the client.


# Update to the latest aliases file
# Usage: aws update-aliases
update-aliases =
    !f() {
      CURL_CLI=$(which curl) || { echo "ERROR: curl not installed." 1>&2 ; return 1 ; }
      CMP_CLI=$(which cmp) || { echo "ERROR: CMP not installed." 1>&2 ; return 1 ; }

      # Update to the latest version of the aliases
      $CURL_CLI --fail -sS https://raw.githubusercontent.com/msaum/aws-alias/master/alias -o ${HOME}/.aws/cli/alias.$$
      if [ -f  "${HOME}/.aws/cli/alias.$$" ]; then
        echo "Downloaded https://raw.githubusercontent.com/msaum/aws-alias/master/alias"
      else
        echo "Unable to download https://raw.githubusercontent.com/msaum/aws-alias/master/alias"
        return 1
      fi
      if $CMP_CLI -s ${HOME}/.aws/cli/alias ${HOME}/.aws/cli/alias.$$; then
        echo "Files are are the same, not updating."
      else
        echo "Files are different, updating ${HOME}/.aws/cli/alias"
        mv -f ${HOME}/.aws/cli/alias.$$ ${HOME}/.aws/cli/alias
      fi
    }; f

# Install and check all prerequisites
install =
  !f() {
    UNAME_CLI=$(which uname) || { echo "ERROR: uname not installed." ; return 1 ; }

	  [ $($UNAME_CLI) = "Darwin" ] &&  {
      echo "OS: OSX / Darwin"
      BREW_CLI=$(which brew) || { echo "ERROR: brew not installed.  Please install brew: https://brew.sh/" 1>&2 ; return 1 ; }
      JQ_CLI=$(which jq) || { echo "ERROR: jq not installed, please install with \"brew install jq\"." 1>&2 ;  }
      JP_CLI=$(which jp) || { echo "ERROR: jp not installed, please install with \"brew install jp\"" 1>&2 ;  }
    }
    [ $($UNAME_CLI) = "Linux" ] && {
      echo "OS: Linux"
      JQ_CLI=$(which jq) || { echo "ERROR: jq not installed, installing" 1>&2 ; sudo apt update ; sudo apt install -y jq ; }
      JP_CLI=$(which jp) || { echo "ERROR: jp not installed, installing" 1>&2 ; sudo apt update ; sudo apt install -y jp ; }
		}

    CHMOD_CLI=$(which chmod) || { echo "ERROR: chmod not found in path." 1>&2 ; return 1 ; }
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    FIND_CLI=$(which find) || { echo "ERROR: find not installed.  Please install find and re-run \"aws install\"." 1>&2 ; return 1 ; }
    SORT_CLI=$(which sort) || { echo "ERROR: sort not installed.  Please install sort and re-run \"aws install\"." 1>&2 ; return 1 ; }
    HEAD_CLI=$(which head) || { echo "ERROR: head not installed.  Please install head and re-run \"aws install\"." 1>&2 ; return 1 ; }
    SED_CLI=$(which sed) || { echo "ERROR: sed not installed.  Please install sed and re-run \"aws install\"." 1>&2 ; return 1 ; }
    GREP_CLI=$(which grep) || { echo "ERROR: grep not installed.  Please install grep and re-run \"aws install\"." 1>&2 ; return 1 ; }
    CUT_CLI=$(which cut) || { echo "ERROR: cut not installed.  Please install cut and re-run \"aws install\"." 1>&2 ; return 1 ; }
    DATE_CLI=$(which date) || { echo "ERROR: date not installed.  Please install date and re-run \"aws install\"." 1>&2 ; return 1 ; }
    REV_CLI=$(which rev) || { echo "ERROR: rev not installed.  Please install rev and re-run \"aws install\"." 1>&2 ; return 1 ; }
    CURL_CLI=$(which curl) || { echo "ERROR: curl not installed.  Please install curl and re-run \"aws install\"." 1>&2 ; return 1 ; }
    PIP3_CLI=$(which pip3) || { echo "ERROR: pip3 not installed.  Please install pip3 and re-run \"aws install\"." 1>&2 ; return 1 ; }
    CMP_CLI=$(which cmp) || { echo "ERROR: cmp not installed. Please install cmp and re-run \"aws install\"." 1>&2 ; return 1 ; }
    TPUT_CLI=$(which tput) || { echo "ERROR: tput not installed. Please install tput and re-run \"aws install\"." 1>&2 ; return 1 ; }
    DOCKER_CLI=$(which docker) || { echo "ERROR: docker not installed. Please install docker and re-run \"aws install\"." 1>&2 ; return 1 ; }
    GETOPT_CLI=$(which getopt) ||
    {
        echo "ERROR: gnugetopt not installed.  Please install GNU getopt and re-run \"aws install\"."  1>&2
        echo "If you are on Mac OSX, use brew to install \"gn--getopt\". https://formulae.brew.sh/formula/gnu-getopt"  1>&2
        return 1
    }

    # Install aws-rotate-iam keys script from GitHub
    $CURL_CLI --fail -sS \
      https://raw.githubusercontent.com/rhyeal/aws-rotate-iam-keys/master/src/bin/aws-rotate-iam-keys \
      -o ${HOME}/.aws/cli/aws-rotate-iam-keys
    if [ -f  "${HOME}/.aws/cli/aws-rotate-iam-keys" ]; then
      echo "Downloaded https://raw.githubusercontent.com/rhyeal/aws-rotate-iam-keys/master/src/bin/aws-rotate-iam-keys"
    else
      echo "ERROR: Unable to download https://raw.githubusercontent.com/rhyeal/aws-rotate-iam-keys/master/src/bin/aws-rotate-iam-keys"  1>&2
      return 1
    fi
    $CHMOD_CLI a+x ${HOME}/.aws/cli/aws-rotate-iam-keys 2> /dev/null

    if [ -x ${HOME}/.aws/cli/aws-rotate-iam-keys ]; then
      echo "aws-rotate-iam-keys successfully installed"
    else
      echo "There was an error installing aws-rotate-iam-keys"
    fi

    # Install aws-mfa Python script using pip3
    echo "Installing aws-mfa Python script using pip3.  Please wait, this may take a long time..."
    $PIP3_CLI install --user --upgrade aws-mfa

    AWS_MFA_CLI=$(which aws-mfa) ||
    {
      # Find the aws-mfa local binary in the usual places
      # Darwin/OSX typical location
      [ -d ${HOME}/Library ] && { AWS_MFA_SEARCH_PATH=$(echo ${AWS_MFA_SEARCH_PATH} ${HOME}/Library) ; }
      # Linux typical location
      [ -d ${HOME}/.local ] && { AWS_MFA_SEARCH_PATH=$(echo ${AWS_MFA_SEARCH_PATH} ${HOME}/.local) ; }
      # Look for the aws-mfa binary
      AWS_MFA_CLI=$($FIND_CLI ${AWS_MFA_SEARCH_PATH} -name aws-mfa -type f | $SORT_CLI -r | $HEAD_CLI -1 )
      [ -x $AWS_MFA_CLI ] && {
        echo "SUCCESS: aws-mfa installed and found at: $AWS_MFA_CLI"
      }
      [ -x $AWS_MFA_CLI ] || {
        echo "ERROR: aws-mfa not found."  1>&2
        return 1
      }
    }
    $AWS_CLI update-aliases

  }; f

# Rotate IAM long term credentials
# https://github.com/rhyeal/aws-rotate-iam-keys
rotate-iam-keys =
  !f() {
    [ "$1" ] && PROFILE=$1
    if [ -z ${PROFILE} ]; then
        echo "Your long term credentials must be provided as an argument."
        echo "If you are using MFA, you cannot use short term credentials to rotate long term credentials."
        echo "For example: use myprofile-long-term not myprofile"
        echo "Usage: aws rotate-iam-keys <profile-long-term>"
        return 1 ;
    else
        ${HOME}/.aws/cli/aws-rotate-iam-keys --profile "$PROFILE"
    fi
    }; f

# Show the number of days remaining on your AWS credential
# Prerequisites:
# - Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws iam-keys-days-remaining
iam-keys-days-remaining =
  !f() {
    [ "$AWS_DEFAULT_PROFILE" ]  && PROFILE=$AWS_DEFAULT_PROFILE
    [ "$AWS_PROFILE" ]          && PROFILE=$AWS_PROFILE
    [ -z "${1}" ] && [ -z "$PROFILE" ] &&
      {
        echo "Can't determine your AWS Profile. Set AWS_PROFILE, or AWS_DEFAULT_PROFILE"
        echo "Usage: aws iam-keys-days-remaining"
        return 1
      }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed."  1>&2 ; return 1 ; }
    SED_CLI=$(which sed) || { echo "ERROR: sed not installed."  1>&2 ; return 1 ; }
    GREP_CLI=$(which grep) || { echo "ERROR: grep not installed."  1>&2 ; return 1 ; }
    CUT_CLI=$(which cut) || { echo "ERROR: cut not installed."  1>&2 ; return 1 ; }
    DATE_CLI=$(which date) || { echo "ERROR: date not installed."  1>&2 ; return 1 ; }
    REV_CLI=$(which rev) || { echo "ERROR: rev not installed."  1>&2 ; return 1 ; }
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path."  1>&2 ; return 1 ; }
    UNAME_CLI=$(which uname) || { echo "ERROR: uname not installed."  1>&2 ; return 1 ; }

    # Set your aws username
    if  USERNAME=$($AWS_CLI sts get-caller-identity | $JQ_CLI .Arn | $SED_CLI 's/.*user\///g' | $SED_CLI 's/\"//g') 2> /dev/null; then
      echo "ERROR: Unable to locate credentials."  1>&2
      return 1
    fi

    if [ "${USERNAME}" = "" ]; then
      echo "ERROR: Unable to determine a user name"  1>&2
      return 1
    fi

    # Get the aws create date for your key ..sample output "2021-02-26T14:41:05+00:00"
    CDATE=$($AWS_CLI iam list-access-keys --output json --user-name ${USERNAME} | $GREP_CLI CreateDate | $CUT_CLI -c 28- | $REV_CLI | $CUT_CLI -c 8- | $REV_CLI |  $SED_CLI -E s/T/\ /g)

    # Use CMPerent code based on the OS, since Darwin uses a CMPerent version of the date command
    [ $($UNAME_CLI) = "Darwin" ] &&  {
        # Get the aws create date for your key ..sample output "2021-02-26T14:41:05+00:00"
        CDATESTRING=$($DATE_CLI -jf "%Y-%m-%d %T" "${CDATE}")

        # Get the expiriation date by adding 60 days to the create date
        EXDATE=$($DATE_CLI -jf "%Y-%m-%d %T" -v +60d "${CDATE}" "+%s")

        # Calulate the number of days between today and the expiration date
        NOW=$($DATE_CLI "+%s")
        DAYSTOEXPIRE=$((($EXDATE - $NOW)/86400))
    }
    # Linux / GNU Code
    [ $($UNAME_CLI) = "Linux" ] && {
        # Get the expiriation date by adding 60 days to the create date
        EXDATE=$($DATE_CLI +"%s" -d"$($DATE_CLI +"%Y-%m-%d+60 days %T" -d"$CDATE")")

        # Calulate the number of days between today and the expiration date
        NOW=$($DATE_CLI +"%s")
        DAYSTOEXPIRE=$((($EXDATE - $NOW)/86400))
    }
    # Display to the user the number of days before the aws keys expire
    printf 'There are %d days left until your aws key expires\n' "${DAYSTOEXPIRE}"

    }; f

###########
### MFA ###
###########

# aws-mfa --duration 129600 --profile myprofile
# Prerequisites:
# - aws-mfa installed (https://pypi.org/project/aws-mfa/)
# - Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws mfa [profile]
mfa =
  !f() {
    SORT_CLI=$(which sort) || { echo "ERROR: sort not installed." 1>&2  ; return 1 ; }
    HEAD_CLI=$(which head) || { echo "ERROR: head not installed."  1>&2 ; return 1 ; }
    FIND_CLI=$(which find) || { echo "ERROR: find not installed."  1>&2 ; return 1 ; }

    [ "$AWS_DEFAULT_PROFILE" ]  && PROFILE=$AWS_DEFAULT_PROFILE
    [ "$AWS_PROFILE" ]          && PROFILE=$AWS_PROFILE

    AWS_MFA_CLI=$(which aws-mfa) ||
    {
      # Find the aws-mfa local binary in the usual places
      # Darwin/OSX typical location
      [ -d ${HOME}/Library ] && { AWS_MFA_SEARCH_PATH=$(echo ${AWS_MFA_SEARCH_PATH} ${HOME}/Library) ; }
      # Linux typical location
      [ -d ${HOME}/.local ] && { AWS_MFA_SEARCH_PATH=$(echo ${AWS_MFA_SEARCH_PATH} ${HOME}/.local) ; }
      # Look for the aws-mfa binary
      AWS_MFA_CLI=$($FIND_CLI ${AWS_MFA_SEARCH_PATH} -name aws-mfa -type f | $SORT_CLI -r | $HEAD_CLI -1 )
      [ -x $AWS_MFA_CLI ] && {
        echo "SUCCESS: aws-mfa installed and found at: $AWS_MFA_CLI"
      }
      [ -x $AWS_MFA_CLI ] || {
        echo "ERROR: aws-mfa not found."  1>&2
        return 1
      }
    }

    [ "${1}" ]    && $AWS_MFA_CLI  --duration 129600 --profile $1
    [ -z "${1}" ] && [ -z "$PROFILE" ] &&
      {
        echo "Can't determine your AWS Profile. Set AWS_PROFILE, AWS_DEFAULT_PROFILE or use an argument."
        echo "Usage: aws mfa [profile]"
        return 1
      }
    [ -z "${1}" ] && $AWS_MFA_CLI  --duration 129600 --profile $PROFILE

  }; f

###########
### IAM ###
###########

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws whoami
whoami =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    $AWS_CLI sts get-caller-identity 2> /dev/null
    [ $? -eq 0 ] || {
      echo "ERROR: Unable to determine your AWS user credentials.  Check your AWS credentials configuration."  1>&2
      return 1
    }
  }; f

# IAM entity to create a specific service role
# https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-service.html
# The ARN for a service-linked role includes a service principal, which is indicated in the policies below as
# SERVICE-NAME.amazonaws.com. Do not try to guess the service principal, because it is case sensitive and the
# format can vary across AWS services. To view the service principal for a service, see its service-linked role
# documentation.
# Usage: aws create-assume-role <rolename> <service>
create-assume-role =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    [ -z "${1}" ] || [ -z "${2}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws create-assume-role <rolename> <service>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} iam create-role --role-name "${1}" \
      --assume-role-policy-document \
        "{\"Statement\":[{\
            \"Action\":\"sts:AssumeRole\",\
            \"Effect\":\"Allow\",\
            \"Principal\":{\"Service\":\""${2}".amazonaws.com\"},\
            \"Sid\":\"\"\
          }],\
          \"Version\":\"2012-10-17\"\
        }";
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Note: If there are a lot of IAM users, this may take some time to run
# Usage: aws find-access-key <access key>
find-access-key =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    TPUT_CLI=$(which tput) || { echo "ERROR: tput not installed." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }

    clear_to_eol=$(${TPUT_CLI} el)
    for i in $($AWS_CLI iam list-users --query "Users[].UserName" --output text); do
      printf "\r%sSearching...$i" "${clear_to_eol}"
      result=$($AWS_CLI iam list-access-keys --output text --user-name "${i}" --query "AccessKeyMetadata[?AccessKeyId=='${1}'].UserName";)
      if [ -n "${result}" ]; then
         printf "\r%s%s is owned by %s.\n" "${lear_to_eol}" "$1" "${result}"
         break
      fi
    done
    if [ -z "${result}" ]; then
      printf "\r%sKey not found." "${clear_to_eol}"
    fi
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-iam-users
list-iam-users =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI iam list-users --query "Users[].UserName" --output table
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-user-keys <username>
list-user-keys =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI iam list-access-keys --output text --user-name "$1" --query "AccessKeyMetadata[].AccessKeyId";
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-virtual-mfa [username]
list-virtual-mfa =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    [ "${1}" ]    && $AWS_CLI iam list-mfa-devices --user-name ${1} | ${JQ_CLI} -r '.MFADevices[] | "Enabled: \(.EnableDate), ARN: \(.SerialNumber)"'
    [ -z "${1}" ] && $AWS_CLI iam list-mfa-devices | ${JQ_CLI} -r '.MFADevices[] | "Enabled: \(.EnableDate), ARN: \(.SerialNumber)"'
  }; f



# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws delete-virtual-mfa <username>
delete-virtual-mfa =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }

    if [ "${1}" = "" ]; then
        echo "ERROR: Missing an argument"
        echo "Usage: aws delete-virtual-mfa <username>"
        return 1
    fi
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    account_id=$($AWS_CLI sts get-caller-identity --output json | ${JQ_CLI} -r '.Account')
    $AWS_CLI iam delete-virtual-mfa-device--serial-number "arn:aws:iam::${account_id}:mfa/$1"
  }; f

# Find users without mfa
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Note: May have issue with large numbers of users due to AWS API throttling
# Usage: aws find-users-without-mfa
find-users-without-mfa =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    echo "Users without MFA enabled:"
    for i in $($AWS_CLI iam list-users --query "Users[?PasswordLastUsed].UserName" --output text); do
      result=$($AWS_CLI iam list-virtual-mfa-devices --query "length(VirtualMFADevices[?User.UserName=='${i}'])")
      if [ "${result}" -eq "0" ]; then
        echo "${i}"
      fi
    done
  }; f

generate-sts-token =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    user_arn=$($AWS_CLI whoami --output json 2> /dev/null | ${JQ_CLI}  -r .Arn)
    duration=${1:-129600}
    session_data=$(${AWS_CLI} sts get-session-token --duration-seconds $duration)
    echo "# temporary credentials on user ${user_arn} for $duration seconds (expires on $(echo $session_data | ${JQ_CLI} -r .Credentials.Expiration))"
    echo "export AWS_DEFAULT_REGION=$($AWS_CLI configure get region)"
    echo "export AWS_ACCESS_KEY_ID=$(echo $session_data | ${JQ_CLI} -r .Credentials.AccessKeyId)"
    echo "export AWS_SECRET_ACCESS_KEY=$(echo $session_data | ${JQ_CLI} -r .Credentials.SecretAccessKey)"
    echo "export AWS_SESSION_TOKEN=$(echo $session_data | ${JQ_CLI} -r .Credentials.SessionToken)"
    echo "export AWS_SECURITY_TOKEN=$(echo $session_data | ${JQ_CLI} -r .Credentials.SessionToken)"
  }; f

# Usage: aws assume <role-arn>
assume =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ "${1}" ] || { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws assume <role-arn>"1>&2 ; return 1; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }

    res=$($AWS_CLI sts assume-role --role-arn ${1} --role-session-name session)
    if echo $res | grep -q AccessKeyId; then
        echo $res \
        | ${JQ_CLI} -r '
        "","[\(.Credentials.AccessKeyId)]",
        "aws_access_key_id     = \(.Credentials.AccessKeyId)",
        "aws_secret_access_key = \(.Credentials.SecretAccessKey)",
        "aws_session_token     = \(.Credentials.SessionToken)",
        "aws_security_token    = \(.Credentials.SessionToken)"
        ' \
        >> ${HOME}/.aws/credentials
        echo $res | ${JQ_CLI} -r '"AWS_PROFILE=\(.Credentials.AccessKeyId)"'
    fi
  }; f

###########
### EC2 ###
###########

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws running-instances
running-instances =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-instances \
    --filter Name=instance-state-name,Values=running \
    --output table \
    --query 'Reservations[].Instances[].{ID: InstanceId,Hostname: PublicDnsName,Name: Tags[?Key==`Name`].Value | [0],Type: InstanceType, Platform: Platform || `Linux`}'
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws ebs-volumes
ebs-volumes=
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI describe-volumes \
    --query 'Volumes[].{VolumeId: VolumeId,State: State,Size: Size,Name: Tags[0].Value,AZ: AvailabilityZone}' \
    --output table
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws amazon-linux-amis
amazon-linux-amis =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI ec2 describe-images \
    --filter \
      Name=owner-alias,Values=amazon \
      Name=name,Values="amzn-ami-hvm-*" \
      Name=architecture,Values=x86_64 \
      Name=virtualization-type,Values=hvm \
      Name=root-device-type,Values=ebs \
      Name=block-device-mapping.volume-type,Values=gp2 \
    --query "reverse(sort_by(Images, &CreationDate))[*].[ImageId,Name,Description]" \
    --output text
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws list-sgs
list-sgs =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI ec2 describe-security-groups --query "SecurityGroups[].[GroupId, GroupName]" --output text
  }; f

# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws sg-rules <security group id>
sg-rules =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws sg-rules <security group id>" 1>&2 ; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI ec2 describe-security-groups \
    --query "SecurityGroups[].IpPermissions[].[FromPort,ToPort,IpProtocol,join(',',IpRanges[].CidrIp)]" \
    --group-id "$1" --output text;
  }; f

# Translates a security group name into a security group id
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws get-group-id <security group name>
get-group-id =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws get-group-id <security group name>" 1>&2 ; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI ec2 describe-security-groups --filters Name=group-name,Values=$
    }{1} --query SecurityGroups[0].GroupId --output text
  }; f


# Usage: aws authorize-my-ip-by-name <security group name>
authorize-my-ip-by-name =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws authorize-my-ip-by-name <security group name>" 1>&2 ; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    group_id=$($AWS_CLI get-group-id "${1}")
    $AWS_CLI authorize-my-ip "$group_id"
  }; f

# list all security group port ranges open to 0.0.0.0/0
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws public-ports
public-ports =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2  return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-security-groups \
      --filters Name=ip-permission.cidr,Values=0.0.0.0/0 \
      --query 'SecurityGroups[].{
        GroupName:GroupName,
        GroupId:GroupId,
        PortRanges:
          IpPermissions[?contains(IpRanges[].CidrIp, `0.0.0.0/0`)].[
            join(`:`, [IpProtocol, join(`-`, [to_string(FromPort), to_string(ToPort)])])
          ][]
      }'
  }; f

# Show my current external ip address
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws myip
my-ip =
  !f() {
    CURL_CLI=$(which curl) || { echo "ERROR: curl not installed." 1>&2 ; return 1 ; }
    ${CURL_CLI} https://checkip.amazonaws.com
  }; f

# allow-my-ip
# Usage: aws allow-my-ip <security group name>
allow-my-ip =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws allow-my-ip <security group name>" 1>&2 ; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    my_ip=$($AWS_CLI myip)
    $AWS_CLI ec2 authorize-security-group-ingress --group-name ${1} --protocol ${2} --port ${3} --cidr $my_ip/32
  }; f

# revoke-my-ip
# Usage: revoke-my-ip <security group name> <protocol> <port>
revoke-my-ip =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] || [ -z "${2}" ] || [ -z "${3}" ]&&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws evoke-my-ip <security group name> <protocol> <port>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    my_ip=$($AWS_CLI myip)
    $AWS_CLI ec2 revoke-security-group-ingress --group-name ${1} --protocol ${2} --port ${3} --cidr $my_ip/32
  }; f

# allow-my-ip-all
# Usage: aws authorize-my-ip-by-name <security group name>
allow-my-ip-all =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws allow-my-ip-all <security group name>" 1>&2; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI allow-my-ip ${1} all all
  }; f

# revoke-my-ip-all
# Usage: aws revoke-my-ip-all <security group name>
revoke-my-ip-all =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws revoke-my-ip-all <security group name>" 1>&2; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    $AWS_CLI revoke-my-ip ${1} all all
  }; f

# Delete an AMI
# Prerequisites: Set a profile to use with either AWS_DEFAULT_PROFILE or AWS_PROFILE to send the profile name as an argument
# Usage: aws delete-ami <AMI ID>
delete-ami =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws delete-ami <AMI ID>" 1>&2 ; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }

    snapshots=$(${AWS_CLI} ec2 describe-images --image-ids $1 --query "Images[].BlockDeviceMappings[].Ebs.SnapshotId" --output text)
    #$AWS_CLI ec2 deregister-image --image-id $1
    for id in $snapshots
    do
      #$AWS_CLI ec2 delete-snapshot --snapshot-id ${id}
      echo $id
    done
  }; f

# list-instances
# Usage: aws list-instances <region>
list-instances =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws list-instances <region>" 1>&2 ; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    echo "Filtering by \`$1\`"
    for region in $($AWS_CLI ec2 describe-regions --query "Regions[*].RegionName" --output text | tr "\t" "\n" | grep "$1")
      do
        echo "\nListing Instances in region:'$region'..."
        $AWS_CLI ec2 describe-instances --region $region \
        --output table \
        --query "Reservations[*].Instances[*].{
                Instance:InstanceId,
                Type:InstanceType,
                AZ:Placement.AvailabilityZone,
                KeyName:KeyName,
                Name:Tags[?Key==\`Name\`]|[0].Value,
                Project:Tags[?Key==\`project\`]|[0].Value,
                IP:PublicIpAddress,
                State:State.Name,
                CPUcores:CpuOptions.CoreCount,
                CPUThreads:CpuOptions.ThreadsPerCore
        }"
      done
  }; f

## connect-ssh
## Usage: aws connect-ssh <instance-id>
#connect-ssh =
#  !f() {
#    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
#    JP_CLI=$(which curl) || { echo "ERROR: jp not installed." 1>&2 ; return 1 ; }
#    [ -z "${1}" ] &&
#      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws list-instances <region>" 1>&2 ; return 1; }
#    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
#
#    instance_output=$(${AWS_CLI} ec2 describe-instances \
#                        --instance-ids "${1}" \
#                        --query Reservations[0].Instances[0])
#
#    ssh_key_file=$(${JP_CLI} -u KeyName << "$instance_output")".pem"
#    public_ip=$(${JP_CLI} -u PublicIpAddress <<< "$instance_output")
#    if ! [ -f "$ssh_key_file" ];
#    then
#      echo "Error: Could not locate SSH key: "$ssh_key_file" in current working directory" 1>&2
#      exit 1
#    fi
#    if [ "$public_ip" == "null" ];
#    then
#      echo "EC2 Instance: "${1}" does not have a public IP address. Unable to connect with SSH."
#      exit 1
#    fi
#    ssh -i "$ssh_key_file" ec2-user@"$public_ip"
#
#  }; f

# search-instances
# Usage: aws search-instances <name>
search-instances =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2; echo "Usage: aws search-instances <name>" 1>&2 ; return 1; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }

    ${AWS_CLI} ec2 describe-instances \
    --filters Name=instance-state-name,Values=running,stopped \
    --query "Reservations[].Instances[].{Name: (Tags[?Key==\`Name\`].Value)[0],
                                        Id: InstanceId,
                                        PrivateIpAddress: PrivateIpAddress,
                                        GroupId: SecurityGroups[].GroupId|join(\`,\`,@)}[?contains(Name,\`"${1}"\`)]" \
    --out table
  }; f

# list-all-regions
# Usage: aws list-all-regions
list-all-regions =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-regions --query "Regions[].RegionName" --output text
  }; f

# list-azs
# Usage: aws list-azs
list-azs =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-availability-zones --region $1 --query AvailabilityZones[].ZoneName --output text;
  }; f
# vpc-peers
# Usage: aws vpc-peers
vpc-peers =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-vpc-peering-connections \
    --query 'VpcPeeringConnections[].Tags[?Key==`Name`].Value' --output text | xargs -n1 | sort -d
  }; f

# find-instances-in-sg
# Usage: aws find-instances-in-sg <network interface group name> <security group id>
find-instances-in-sg =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] || [ -z "${2}" ]  &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws find-instances-in-sg <network interface group name> <security group id>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    filter=${2:-Name}
    for i in $(${AWS_CLI} ec2 describe-instances --filters "Name=network-interface.group-id,Values=['${1}']" --query "Reservations[].Instances[].Tags[?Key == '${filter}'].Value[]" --output text)
    do
      echo ${i}
    done
  }; f

# find-ssh-open
# Usage: aws find-ssh-open
find-ssh-open =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-security-groups \
      --filters Name=ip-permission.from-port,Values=22 \
      --query "SecurityGroups[].{
        GroupName: GroupName,
        GroupId: GroupId,
        IPs: IpPermissions[?to_string(FromPort) == '22'][IpRanges[].CidrIp][][]
      }"
  }; f

# get-asg-instance-ips
# Usage: aws get-asg-instance-ips <ASG Name>
get-asg-instance-ips =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws get-asg-instance-ips <ASG Name>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    asg_name=${1}
    ${AWS_CLI} ec2 describe-instances --filters "Name=tag:aws:autoscaling:groupName,Values=${asg_name}" | ${JQ_CLI} -r '.Reservations[].Instances[].PrivateIpAddress'
  }; f

# find-host-by-instance-id
# Usage: aws find-host-by-instance-id <instance ID>
find-host-by-instance-id =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws find-host-by-instance-id <instance ID>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    instance_id=${1}
    ${AWS_CLI} ec2 describe-instances --filters "Name=instance-id,Values=${instance_id}" | ${JQ_CLI} -r '.Reservations[].Instances[].PrivateIpAddress' | sed -E 's/\./-/g; s/^/ip-/'
  }; f

#find-instance-by-public-ip
# Usage: aws find-instance-by-public-ip <public ip>
find-instance-by-public-ip =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws find-instance-by-public-ip <public ip>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-instances --filters "Name=ip-address,Values=$1" | ${JQ_CLI} -r '.Reservations[].Instances[].Tags[] | select(.Key == "Name").Value'
  }; f

#find-nat-gateway-by-public-ip
# Usage: aws find-nat-gateway-by-public-ip <public ip>
find-nat-gateway-by-public-ip =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws find-nat-gateway-by-public-ip <public ip>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-nat-gateways | ${JQ_CLI} -r '.NatGateways[] | select(.NatGatewayAddresses[].PublicIp == "'$1'") | .Tags[] | select(.Key == "Name").Value'
  }; f

#list-igw
# Usage: list-igw <public ip>
list-igw = ec2 describe-internet-gateways \
    --query "InternetGateways[].{IGW:InternetGatewayId,VpcId: Attachments[].VpcId|[0], Name: Tags[?Key=='Name'].Value |[0] }"  \
    --output table

# list-ngw
# Usage: aws list-ngw
list-ngw = ec2 describe-nat-gateways \
    --query "NatGateways[].{VpcId:VpcId, NatGatewayId: NatGatewayId, SubnetId: SubnetId, PublicIp: NatGatewayAddresses[].PublicIp | [0], PrivateIp: NatGatewayAddresses[].PrivateIp | [0] }" \
    --output table

#list-vgw
# Usage: aws list-vgw
list-vgw = ec2 describe-vpn-gateways \
    --query "VpnGateways[].{VpnGatewayId: VpnGatewayId, AmazonSideAsn: AmazonSideAsn, VpcId: VpcAttachments.VpcId,Name: Tags[?Key=='Name'].Value| [0] }" \
    --output table
#list-vpn-connection
# Usage: aws list-vpn-connection
list-vpn-connection = ec2 describe-vpn-connections \
    --query "VpnConnections[].{ VpnConnectionId: VpnConnectionId, CustomerGatewayId:CustomerGatewayId,VpnGatewayId:VpnGatewayId, Name: Tags[?Key=='Name'].Value| [0] }" \
    --output table

#list-instance-status
# Usage: aws list-instance-status
list-instance-status = ec2 describe-instance-status \
    --query "InstanceStatuses[].{InstanceId: InstanceId, State: InstanceState.Name, AZ: AvailabilityZone, SystemStatus: SystemStatus.Status, InstanceStatus: InstanceStatus.Status}" \
    --output table

#list-vpcs
# Usage: aws list-vpcs
list-vpcs = ec2 describe-vpcs \
      --query \
        "Vpcs[].{VpcId: VpcId, CidrBlock: CidrBlock,  Name: Tags[?Key=='Name'].Value| [0], IsDefault: IsDefault}" \
      --output table

#list-subnets
# Usage: aws list-subnets
list-subnets = ec2 describe-subnets \
    --query "Subnets[].{AZ:AvailabilityZone,VpcId:VpcId,SubnetId:SubnetId,CidrBlock:CidrBlock,    Name: Tags[?Key=='Name'].Value| [0]}" \
    --output table

#list-routes
# Usage: aws list-routes
list-routes = ec2 describe-route-tables \
  --query "RouteTables[].{RouteTableId:RouteTableId, VpcId:VpcId, Name: Tags[?Key=='Name'].Value| [0], GatewayId: Routes[].{GatewayId:GatewayId,DestinationCidrBlock: DestinationCidrBlock} }  " \
  --output table

#get-dns-from-instance-id
# Usage: aws get-dns-from-instance-id <instance id>
get-dns-from-instance-id =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws get-dns-from-instance-id <instance id>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-instances \
      --instance-ids "${1}" \
      --query 'Reservations[*].Instances[*][PublicDnsName,InstanceId]' --output text | cut -f1
  }; f

#get-instance-id-from-dns
# Usage: aws get-instance-id-from-dns <dns name>
get-instance-id-from-dns =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
      [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws get-dns-from-instance-id <instance id>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ec2 describe-instances \
    --filters "Name=dns-name,Values=${1}" \
    --query 'Reservations[*].Instances[*][InstanceId,PublicDnsName]' --output text | cut -f1
  }; f

################
## Cloudwatch ##
################

# log-groups
# Usage: aws log-groups
log-groups =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} logs describe-log-groups | ${JQ_CLI} '.logGroups[].logGroupName'  | sed 's/\"//g'
  }; f

#last-log
# Usage: aws last-log <log group>
last-log =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws get-dns-from-instance-id <instance id>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    group="$1"
    if ! stream="$(${AWS_CLI} logs describe-log-streams --log-group-name "$group" \
      --max-items 1 --order-by LastEventTime --descending \
      --query "logStreams[0].logStreamName" --output "text")"; then
      return 1
    fi
    stream="${stream%[[:space:]]None}"
    ${AWS_CLI} logs get-log-events --log-group-name "$group" --log-stream-name "$stream" \
      --query "events[].message" --output "text"
  }; f

##########
## ECR ###
##########
# docker-ecr-login
# Usage: aws docker-ecr-login
docker-ecr-login =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    DOCKER_CLI=$(which docker) || { echo "ERROR: docker not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    region=$(${AWS_CLI} configure get region)
    endpoint=$(${AWS_CLI} ecr get-authorization-token --region $region --output text --query authorizationData[].proxyEndpoint)
    passwd=$(${AWS_CLI} ecr get-authorization-token --region $region --output text --query authorizationData[].authorizationToken | base64 --decode | cut -d: -f2)
    ${DOCKER_CLI} login -u AWS -p $passwd $endpoint
  }; f

# ecr-list-repositories
ecr-list-repositories =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ecr describe-repositories   |  jq -r '.repositories[].repositoryArn'
  }; f


# ecr-scan-findings
# Usage: aws ecr-scan-findings <repo name>
ecr-scan-findings =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }
    [ -z "${1}" ] &&
      { echo "ERROR: Missing an argument" 1>&2 ; echo "Usage: aws evoke-my-ip <security group name> <protocol> <port>" 1>&2; return 1;  }
    ${AWS_CLI} whoami > /dev/null || { return 1 ; }
    ${AWS_CLI} ecr describe-image-scan-findings --repository-name "${1}" --image-id imageTag=latest | ${JQ_CLI} -r '.imageScanFindings.findings[] | "\(.severity) \(.name) \(.uri)"' | sort
  }; f





##################
## Securityhub ###
##################
# sh-quick-report
# Usage: sh-quick-report
sh-quick-report =
  !f() {
    AWS_CLI=$(which aws) || { echo "ERROR: I can't seem to find the AWS binary in the path." 1>&2 ; return 1 ; }
    JQ_CLI=$(which jq) || { echo "ERROR: jq not installed." 1>&2 ; return 1 ; }

    $AWS_CLI whoami > /dev/null || { return 1 ; }
    CRITICAL=$(mktemp --suffix=.json)
    HIGH=$(mktemp --suffix=.json)
    MEDIUM=$(mktemp --suffix=.json)
    LOW=$(mktemp --suffix=.json)
    INFO=$(mktemp --suffix=.json)

    trap 'echo "EXIT detected with exit status $?" ; rm -f "$CRITICAL"; rm -f "$HIGH"; rm -f "$MEDIUM"; rm -f "$LOW"; rm -f "$INFO"' EXIT
    echo "Security Hub Quick Summary Report"
    echo "================================="

    ${AWS_CLI}  securityhub get-findings --filters '{"SeverityLabel":[{"Value": "CRITICAL","Comparison":"EQUALS"}],"WorkflowStatus": [{"Value":"NEW","Comparison":"EQUALS"}],"RecordState":[{"Value":"ACTIVE","Comparison":"EQUALS"}]}' > "$CRITICAL"

    printf "Total CRITICAL findings count (if any): $(${JQ_CLI} '.[] | length' < "$CRITICAL" )\n"
    printf "Unique issues list (if any): \n"
    ${JQ_CLI} '.Findings[].Title' < $CRITICAL | sort | uniq  | tr -d '"' | sed 's/^/- /'

    ${AWS_CLI}  securityhub get-findings --filters '{"SeverityLabel":[{"Value": "HIGH","Comparison":"EQUALS"}],"WorkflowStatus": [{"Value":"NEW","Comparison":"EQUALS"}],"RecordState":[{"Value":"ACTIVE","Comparison":"EQUALS"}]}' > "$HIGH"
    printf "\nTotal HIGH findings count: $(${JQ_CLI} '.[] | length' < "$HIGH" )\n"
    echo "Unique issues list, if any:"
    ${JQ_CLI} '.Findings[].Title' < $HIGH | sort | uniq  | tr -d '"' | sed 's/^/- /'

    aws securityhub get-findings --filters '{"SeverityLabel":[{"Value": "MEDIUM","Comparison":"EQUALS"}],"WorkflowStatus": [{"Value":"NEW","Comparison":"EQUALS"}],"RecordState":[{"Value":"ACTIVE","Comparison":"EQUALS"}]}' > "$MEDIUM"
    printf "\nTotal MEDIUM findings count (if any): $(${JQ_CLI} '.[] | length' < "$MEDIUM" )\n"
    echo "Unique issues list, if any:"
    ${JQ_CLI} '.Findings[].Title' < $MEDIUM | sort | uniq  | tr -d '"' | sed 's/^/- /'

    ${AWS_CLI}  securityhub get-findings --filters '{"SeverityLabel":[{"Value": "LOW","Comparison":"EQUALS"}],"WorkflowStatus": [{"Value":"NEW","Comparison":"EQUALS"}],"RecordState":[{"Value":"ACTIVE","Comparison":"EQUALS"}]}' > "$LOW"
    printf "\nTotal LOW findings count (if any): $(${JQ_CLI} '.[] | length' < "$LOW" )\n"
    echo "Unique issues list, if any:"
    ${JQ_CLI} '.Findings[].Title' < $LOW | sort | uniq  | tr -d '"' | sed 's/^/- /'

    ${AWS_CLI}  securityhub get-findings --filters '{"SeverityLabel":[{"Value": "INFO","Comparison":"EQUALS"}],"WorkflowStatus": [{"Value":"NEW","Comparison":"EQUALS"}],"RecordState":[{"Value":"ACTIVE","Comparison":"EQUALS"}]}' > "$INFO"
    printf "\nTotal INFO findings count (if any): $(${JQ_CLI} '.[] | length' < "$INFO" )\n"
    echo "Unique issues list, if any:"
    ${JQ_CLI} '.Findings[].Title' < $INFO | sort | uniq  | tr -d '"' | sed 's/^/- /'

  }; f

